C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.14 (r7260) - 18 Jan 2019 10:11
C
C  Differentiation of aresid in forward (tangent) mode:
C   variations   of useful results: flow residual
C   with respect to varying inputs: alpha flow
C   RW status of diff variables: alpha:in flow:in-out residual:out
C**********************************************************************!
C                          Charlie Anderson                            !
C                  University of Bristol, March 2019                   !
C**********************************************************************!
C    
      SUBROUTINE ARESID_D(nx, ny, nl, flow, flowd, residual, residuald, 
     +                    np, params, dt, na, alpha, alphad)
      IMPLICIT NONE
C
C
C
C
C
      INTEGER nx, ny, nl, np, na
      INTEGER i, j
C
      DOUBLE PRECISION xa, xb, xc, xd, ya, yb, yc, yd, area
      DOUBLE PRECISION xad, xbd, xcd, xdd, yad, ybd, ycd, ydd, aread
      DOUBLE PRECISION pi
C
      DOUBLE PRECISION, DIMENSION(1, na) :: alpha
      DOUBLE PRECISION alphad(1, na)
      DOUBLE PRECISION, DIMENSION(1, np) :: params
      DOUBLE PRECISION, DIMENSION(4) :: fa, fb, fc, fd, ga, gb, gc, gd, 
     +                                  da, db, dc, dd
      DOUBLE PRECISION fad(4), fbd(4), fcd(4), fdd(4), gad(4), gbd(4), 
     +                 gcd(4), gdd(4), dad(4), dbd(4), dcd(4), ddd(4)
      DOUBLE PRECISION, DIMENSION(1, 4*(nx+2*nl)*(ny+2*nl)) :: flow, 
     +                                                         residual
      DOUBLE PRECISION flowd(1, 4*(nx+2*nl)*(ny+2*nl)), residuald(1, 4*(
     +                 nx+2*nl)*(ny+2*nl))
      DOUBLE PRECISION, DIMENSION(0-nl:nx+nl, 0-nl:ny+nl) :: meshx, 
     +                                                       meshy
      DOUBLE PRECISION meshxd(0-nl:nx+nl, 0-nl:ny+nl), meshyd(0-nl:nx+nl
     +                 , 0-nl:ny+nl)
      DOUBLE PRECISION, DIMENSION(1-nl:nx+nl, 1-nl:ny+nl) :: u1, u2, u3
     +                                                       , u5, r1, 
     +                                                       r2, r3, r5
     +                                                       , volume, 
     +                                                       dt
      DOUBLE PRECISION u1d(1-nl:nx+nl, 1-nl:ny+nl), u2d(1-nl:nx+nl, 1-nl
     +                 :ny+nl), u3d(1-nl:nx+nl, 1-nl:ny+nl), u5d(1-nl:nx
     +                 +nl, 1-nl:ny+nl), r1d(1-nl:nx+nl, 1-nl:ny+nl), 
     +                 r2d(1-nl:nx+nl, 1-nl:ny+nl), r3d(1-nl:nx+nl, 1-nl
     +                 :ny+nl), r5d(1-nl:nx+nl, 1-nl:ny+nl), volumed(1-
     +                 nl:nx+nl, 1-nl:ny+nl)
      INTRINSIC DABS
      DOUBLE PRECISION dabs0
      DOUBLE PRECISION dabs0d
      DOUBLE PRECISION dabs1
      DOUBLE PRECISION dabs1d
      INTEGER ii2
      INTEGER ii1
C
C
C
C
C
C
C
C
C
C     Visualise the cell in three dimensions to see cross product
C
C                                mesh(i-1,j)         mesh(i,j)
C       z|                             .______________.
C        |   /y                       /       B      ^           
C        |  /                        /              /
C        | /                        /C            A/--------->n_A
C        |/______                  /              /
C               x                 /_______D______/
C                         mesh(i-1,j-1)          mesh(i,j-1)
C
C
C     Make sure to form the correct "face triangles" to get the right
C     normal
C      
C                             xA
C              .__________.<____.    
C     y|        \     B    \    ^  
C      |         \          \   |                        xA   0     yA
C      |          \C        A\  |yA     n.dS = A X k  =  yA X 0  = -xA 
C      |_____      \          \ |                         0   1      0
C           x       \____D_____\|
C
C
C     Area of a triangle between vectors P and Q for use in the cell
C     area calculation
C                                           area = 0.5*|PXQ|
C                                                = 0.5*|xP.yQ-xQ.yP|
C        
C
C
C        
C     When caulation the fluxes for each face use the definitions below
C     for example F_A = F(U(i+1/2,j))   
C        
C
C         *-------------*-------------*-------------*
C         |             |             |             |
C         |             |    i,j+1    |             |    A = (i+1/2,j)
C         |             |             |             |
C         *-------------*------B------*-------------*    B = (i,j+1/2)
C         |             |             |             |
C         |    i-1,j    C     i,j     A    i+1,j    |    C = (i-1/2,j)
C         |             |             |             |
C         *-------------*------D------*-------------*    D = (i,j-1/2)
C         |             |             |             |
C         |             |    i,j-1    |             |
C         |             |             |             |
C         *-------------*-------------*-------------*
C
C     A face: i+1/2 , j
C     B face: i     , j+1/2
C     C face: i-1/2 , j
C     D face: i     , j-1/2
C
C
C
C
C
C
C
C
C   
C     apply boundary conditions and calculate pressure field
C
      CALL MESHING_D(nx, ny, na, nl, alpha, alphad, meshx, meshxd, meshy
     +               , meshyd, np, params)
C
      CALL SPLIT_FWD_D(nx, ny, nl, flow, flowd, u1, u1d, u2, u2d, u3, 
     +                 u3d, u5, u5d)
      CALL SPLIT_FWD(nx, ny, nl, residual, r1, r2, r3, r5)
C
      CALL BOUNDARIES_D(nx, ny, nl, np, params, u1, u1d, u2, u2d, u3, 
     +                  u3d, u5, u5d, meshx, meshxd, meshy, meshyd)
C
C
      DO i=1,4
        da(i) = 0.0d0
        db(i) = 0.0d0
        dc(i) = 0.0d0
        dd(i) = 0.0d0
      ENDDO
C
C
C
C     calculate cell area
C
      pi = 3.1415926535897932d0
      DO ii1=1-nl,nl+ny
        DO ii2=1-nl,nl+nx
          volumed(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
C
      DO j=1-nl,ny+nl
        DO i=1-nl,nx+nl
C
C
          xad = meshxd(i, j) - meshxd(i, j-1)
          xa = meshx(i, j) - meshx(i, j-1)
          xbd = meshxd(i-1, j) - meshxd(i, j)
          xb = meshx(i-1, j) - meshx(i, j)
          xcd = meshxd(i-1, j-1) - meshxd(i-1, j)
          xc = meshx(i-1, j-1) - meshx(i-1, j)
          xdd = meshxd(i, j-1) - meshxd(i-1, j-1)
          xd = meshx(i, j-1) - meshx(i-1, j-1)
          yad = meshyd(i, j) - meshyd(i, j-1)
          ya = meshy(i, j) - meshy(i, j-1)
          ybd = meshyd(i-1, j) - meshyd(i, j)
          yb = meshy(i-1, j) - meshy(i, j)
          ycd = meshyd(i-1, j-1) - meshyd(i-1, j)
          yc = meshy(i-1, j-1) - meshy(i-1, j)
          ydd = meshyd(i, j-1) - meshyd(i-1, j-1)
          yd = meshy(i, j-1) - meshy(i-1, j-1)
          IF (xa*yb - xb*ya .GE. 0.) THEN
            dabs0d = xad*yb + xa*ybd - xbd*ya - xb*yad
            dabs0 = xa*yb - xb*ya
          ELSE
            dabs0d = -(xad*yb+xa*ybd-xbd*ya-xb*yad)
            dabs0 = -(xa*yb-xb*ya)
          END IF
          IF (xc*yd - xd*yc .GE. 0.) THEN
            dabs1d = xcd*yd + xc*ydd - xdd*yc - xd*ycd
            dabs1 = xc*yd - xd*yc
          ELSE
            dabs1d = -(xcd*yd+xc*ydd-xdd*yc-xd*ycd)
            dabs1 = -(xc*yd-xd*yc)
          END IF
C
C
C
          volumed(i, j) = 0.5d0*dabs0d + 0.5d0*dabs1d
          volume(i, j) = 0.5d0*dabs0 + 0.5d0*dabs1
        ENDDO
      ENDDO
      DO ii1=1,4
        ddd(ii1) = 0.D0
      ENDDO
      DO ii1=1,4
        fad(ii1) = 0.D0
      ENDDO
      DO ii1=1,4
        fbd(ii1) = 0.D0
      ENDDO
      DO ii1=1,4
        fcd(ii1) = 0.D0
      ENDDO
      DO ii1=1,4
        fdd(ii1) = 0.D0
      ENDDO
      DO ii1=1-nl,nl+ny
        DO ii2=1-nl,nl+nx
          r1d(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1-nl,nl+ny
        DO ii2=1-nl,nl+nx
          r2d(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1-nl,nl+ny
        DO ii2=1-nl,nl+nx
          r3d(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1-nl,nl+ny
        DO ii2=1-nl,nl+nx
          r5d(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,4
        gad(ii1) = 0.D0
      ENDDO
      DO ii1=1,4
        gbd(ii1) = 0.D0
      ENDDO
      DO ii1=1,4
        gcd(ii1) = 0.D0
      ENDDO
      DO ii1=1,4
        gdd(ii1) = 0.D0
      ENDDO
      DO ii1=1,4
        dad(ii1) = 0.D0
      ENDDO
      DO ii1=1,4
        dbd(ii1) = 0.D0
      ENDDO
      DO ii1=1,4
        dcd(ii1) = 0.D0
      ENDDO
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C     Perform finite volume calculation over body cells
C
      DO j=1,ny
        DO i=1,nx
C
C     calculate geometric information
C
          xad = meshxd(i, j) - meshxd(i, j-1)
          xa = meshx(i, j) - meshx(i, j-1)
          xbd = meshxd(i-1, j) - meshxd(i, j)
          xb = meshx(i-1, j) - meshx(i, j)
          xcd = meshxd(i-1, j-1) - meshxd(i-1, j)
          xc = meshx(i-1, j-1) - meshx(i-1, j)
          xdd = meshxd(i, j-1) - meshxd(i-1, j-1)
          xd = meshx(i, j-1) - meshx(i-1, j-1)
          yad = meshyd(i, j) - meshyd(i, j-1)
          ya = meshy(i, j) - meshy(i, j-1)
          ybd = meshyd(i-1, j) - meshyd(i, j)
          yb = meshy(i-1, j) - meshy(i, j)
          ycd = meshyd(i-1, j-1) - meshyd(i-1, j)
          yc = meshy(i-1, j-1) - meshy(i-1, j)
          ydd = meshyd(i, j-1) - meshyd(i-1, j-1)
          yd = meshy(i, j-1) - meshy(i-1, j-1)
C
          aread = volumed(i, j)
          area = volume(i, j)
C
C
C
C
C
C
C
C     create F and G vector
C
C     A face: i+1/2 , j
          CALL FG_VECTOR_D(fa, fad, ga, gad, 0.5d0*(u1(i+1, j)+u1(i, j))
     +                     , 0.5d0*(u1d(i+1, j)+u1d(i, j)), 0.5d0*(u2(i+
     +                     1, j)+u2(i, j)), 0.5d0*(u2d(i+1, j)+u2d(i, j)
     +                     ), 0.5d0*(u3(i+1, j)+u3(i, j)), 0.5d0*(u3d(i+
     +                     1, j)+u3d(i, j)), 0.5d0*(u5(i+1, j)+u5(i, j))
     +                     , 0.5d0*(u5d(i+1, j)+u5d(i, j)))
C
C     B face: i     , j+1/2
          CALL FG_VECTOR_D(fb, fbd, gb, gbd, 0.5d0*(u1(i, j+1)+u1(i, j))
     +                     , 0.5d0*(u1d(i, j+1)+u1d(i, j)), 0.5d0*(u2(i
     +                     , j+1)+u2(i, j)), 0.5d0*(u2d(i, j+1)+u2d(i, j
     +                     )), 0.5d0*(u3(i, j+1)+u3(i, j)), 0.5d0*(u3d(i
     +                     , j+1)+u3d(i, j)), 0.5d0*(u5(i, j+1)+u5(i, j)
     +                     ), 0.5d0*(u5d(i, j+1)+u5d(i, j)))
C
C     C face: i-1/2 , j
          CALL FG_VECTOR_D(fc, fcd, gc, gcd, 0.5d0*(u1(i-1, j)+u1(i, j))
     +                     , 0.5d0*(u1d(i-1, j)+u1d(i, j)), 0.5d0*(u2(i-
     +                     1, j)+u2(i, j)), 0.5d0*(u2d(i-1, j)+u2d(i, j)
     +                     ), 0.5d0*(u3(i-1, j)+u3(i, j)), 0.5d0*(u3d(i-
     +                     1, j)+u3d(i, j)), 0.5d0*(u5(i-1, j)+u5(i, j))
     +                     , 0.5d0*(u5d(i-1, j)+u5d(i, j)))
C
C     D face: i     , j-1/2
          CALL FG_VECTOR_D(fd, fdd, gd, gdd, 0.5d0*(u1(i, j-1)+u1(i, j))
     +                     , 0.5d0*(u1d(i, j-1)+u1d(i, j)), 0.5d0*(u2(i
     +                     , j-1)+u2(i, j)), 0.5d0*(u2d(i, j-1)+u2d(i, j
     +                     )), 0.5d0*(u3(i, j-1)+u3(i, j)), 0.5d0*(u3d(i
     +                     , j-1)+u3d(i, j)), 0.5d0*(u5(i, j-1)+u5(i, j)
     +                     ), 0.5d0*(u5d(i, j-1)+u5d(i, j)))
C
C
C
C
C
C     do JST stuff
C
          CALL JST_CALCS_D(dt(i, j), np, params, da, dad, volume(i+1, j)
     +                     , volumed(i+1, j), volume(i, j), volumed(i, j
     +                     ), u1(i+2, j), u1d(i+2, j), u1(i+1, j), u1d(i
     +                     +1, j), u1(i, j), u1d(i, j), u1(i-1, j), u1d(
     +                     i-1, j), u2(i+2, j), u2d(i+2, j), u2(i+1, j)
     +                     , u2d(i+1, j), u2(i, j), u2d(i, j), u2(i-1, j
     +                     ), u2d(i-1, j), u3(i+2, j), u3d(i+2, j), u3(i
     +                     +1, j), u3d(i+1, j), u3(i, j), u3d(i, j), u3(
     +                     i-1, j), u3d(i-1, j), u5(i+2, j), u5d(i+2, j)
     +                     , u5(i+1, j), u5d(i+1, j), u5(i, j), u5d(i, j
     +                     ), u5(i-1, j), u5d(i-1, j))
C
          CALL JST_CALCS_D(dt(i, j), np, params, db, dbd, volume(i, j+1)
     +                     , volumed(i, j+1), volume(i, j), volumed(i, j
     +                     ), u1(i, j+2), u1d(i, j+2), u1(i, j+1), u1d(i
     +                     , j+1), u1(i, j), u1d(i, j), u1(i, j-1), u1d(
     +                     i, j-1), u2(i, j+2), u2d(i, j+2), u2(i, j+1)
     +                     , u2d(i, j+1), u2(i, j), u2d(i, j), u2(i, j-1
     +                     ), u2d(i, j-1), u3(i, j+2), u3d(i, j+2), u3(i
     +                     , j+1), u3d(i, j+1), u3(i, j), u3d(i, j), u3(
     +                     i, j-1), u3d(i, j-1), u5(i, j+2), u5d(i, j+2)
     +                     , u5(i, j+1), u5d(i, j+1), u5(i, j), u5d(i, j
     +                     ), u5(i, j-1), u5d(i, j-1))
C
          CALL JST_CALCS_D(dt(i, j), np, params, dc, dcd, volume(i, j), 
     +                     volumed(i, j), volume(i-1, j), volumed(i-1, j
     +                     ), u1(i+1, j), u1d(i+1, j), u1(i, j), u1d(i, 
     +                     j), u1(i-1, j), u1d(i-1, j), u1(i-2, j), u1d(
     +                     i-2, j), u2(i+1, j), u2d(i+1, j), u2(i, j), 
     +                     u2d(i, j), u2(i-1, j), u2d(i-1, j), u2(i-2, j
     +                     ), u2d(i-2, j), u3(i+1, j), u3d(i+1, j), u3(i
     +                     , j), u3d(i, j), u3(i-1, j), u3d(i-1, j), u3(
     +                     i-2, j), u3d(i-2, j), u5(i+1, j), u5d(i+1, j)
     +                     , u5(i, j), u5d(i, j), u5(i-1, j), u5d(i-1, j
     +                     ), u5(i-2, j), u5d(i-2, j))
C
C
          CALL JST_CALCS_D(dt(i, j), np, params, dd, ddd, volume(i, j), 
     +                     volumed(i, j), volume(i, j-1), volumed(i, j-1
     +                     ), u1(i, j+1), u1d(i, j+1), u1(i, j), u1d(i, 
     +                     j), u1(i, j-1), u1d(i, j-1), u1(i, j-2), u1d(
     +                     i, j-2), u2(i, j+1), u2d(i, j+1), u2(i, j), 
     +                     u2d(i, j), u2(i, j-1), u2d(i, j-1), u2(i, j-2
     +                     ), u2d(i, j-2), u3(i, j+1), u3d(i, j+1), u3(i
     +                     , j), u3d(i, j), u3(i, j-1), u3d(i, j-1), u3(
     +                     i, j-2), u3d(i, j-2), u5(i, j+1), u5d(i, j+1)
     +                     , u5(i, j), u5d(i, j), u5(i, j-1), u5d(i, j-1
     +                     ), u5(i, j-2), u5d(i, j-2))
C
C
C
C
C
C
C
C
C
C
C
C
C     calculate residual for specific cell; subtract dissipation terms
C     from original FV section
C
          r1d(i, j) = ((fad(1)*ya-ga(1)*xad-gad(1)*xa+fa(1)*yad-gbd(1)*
     +      xb-gb(1)*xbd+fbd(1)*yb+fb(1)*ybd-gcd(1)*xc-gc(1)*xcd+fcd(1)*
     +      yc+fc(1)*ycd-gdd(1)*xd-gd(1)*xdd+fdd(1)*yd+fd(1)*ydd-dad(1)-
     +      dbd(1)+dcd(1)+ddd(1))*area-(-(ga(1)*xa)+fa(1)*ya-gb(1)*xb+fb
     +      (1)*yb-gc(1)*xc+fc(1)*yc-gd(1)*xd+fd(1)*yd-(da(1)+db(1)-dc(1
     +      )-dd(1)))*aread)/area**2
          r1(i, j) = (-(ga(1)*xa)+fa(1)*ya-gb(1)*xb+fb(1)*yb-gc(1)*xc+fc
     +      (1)*yc-gd(1)*xd+fd(1)*yd-(da(1)+db(1)-dc(1)-dd(1)))/area
C
          r2d(i, j) = ((fad(2)*ya-ga(2)*xad-gad(2)*xa+fa(2)*yad-gbd(2)*
     +      xb-gb(2)*xbd+fbd(2)*yb+fb(2)*ybd-gcd(2)*xc-gc(2)*xcd+fcd(2)*
     +      yc+fc(2)*ycd-gdd(2)*xd-gd(2)*xdd+fdd(2)*yd+fd(2)*ydd-dad(2)-
     +      dbd(2)+dcd(2)+ddd(2))*area-(-(ga(2)*xa)+fa(2)*ya-gb(2)*xb+fb
     +      (2)*yb-gc(2)*xc+fc(2)*yc-gd(2)*xd+fd(2)*yd-(da(2)+db(2)-dc(2
     +      )-dd(2)))*aread)/area**2
          r2(i, j) = (-(ga(2)*xa)+fa(2)*ya-gb(2)*xb+fb(2)*yb-gc(2)*xc+fc
     +      (2)*yc-gd(2)*xd+fd(2)*yd-(da(2)+db(2)-dc(2)-dd(2)))/area
C
          r3d(i, j) = ((fad(3)*ya-ga(3)*xad-gad(3)*xa+fa(3)*yad-gbd(3)*
     +      xb-gb(3)*xbd+fbd(3)*yb+fb(3)*ybd-gcd(3)*xc-gc(3)*xcd+fcd(3)*
     +      yc+fc(3)*ycd-gdd(3)*xd-gd(3)*xdd+fdd(3)*yd+fd(3)*ydd-dad(3)-
     +      dbd(3)+dcd(3)+ddd(3))*area-(-(ga(3)*xa)+fa(3)*ya-gb(3)*xb+fb
     +      (3)*yb-gc(3)*xc+fc(3)*yc-gd(3)*xd+fd(3)*yd-(da(3)+db(3)-dc(3
     +      )-dd(3)))*aread)/area**2
          r3(i, j) = (-(ga(3)*xa)+fa(3)*ya-gb(3)*xb+fb(3)*yb-gc(3)*xc+fc
     +      (3)*yc-gd(3)*xd+fd(3)*yd-(da(3)+db(3)-dc(3)-dd(3)))/area
C
          r5d(i, j) = ((fad(4)*ya-ga(4)*xad-gad(4)*xa+fa(4)*yad-gbd(4)*
     +      xb-gb(4)*xbd+fbd(4)*yb+fb(4)*ybd-gcd(4)*xc-gc(4)*xcd+fcd(4)*
     +      yc+fc(4)*ycd-gdd(4)*xd-gd(4)*xdd+fdd(4)*yd+fd(4)*ydd-dad(4)-
     +      dbd(4)+dcd(4)+ddd(4))*area-(-(ga(4)*xa)+fa(4)*ya-gb(4)*xb+fb
     +      (4)*yb-gc(4)*xc+fc(4)*yc-gd(4)*xd+fd(4)*yd-(da(4)+db(4)-dc(4
     +      )-dd(4)))*aread)/area**2
          r5(i, j) = (-(ga(4)*xa)+fa(4)*ya-gb(4)*xb+fb(4)*yb-gc(4)*xc+fc
     +      (4)*yc-gd(4)*xd+fd(4)*yd-(da(4)+db(4)-dc(4)-dd(4)))/area
        ENDDO
      ENDDO
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
      CALL SPLIT_REV_D(nx, ny, nl, flow, flowd, u1, u1d, u2, u2d, u3, 
     +                 u3d, u5, u5d)
      DO ii1=1,4*(nx+2*nl)*(ny+2*nl)
        DO ii2=1,1
          residuald(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      CALL SPLIT_REV_D(nx, ny, nl, residual, residuald, r1, r1d, r2, r2d
     +                 , r3, r3d, r5, r5d)
      END

C  Differentiation of meshing in forward (tangent) mode:
C   variations   of useful results: meshx meshy
C   with respect to varying inputs: alpha
C**********************************************************************!
C                          Charlie Anderson                            !
C                  University of Bristol, March 2019                   !
C**********************************************************************!
C    
      SUBROUTINE MESHING_D(nx, ny, na, nl, alpha, alphad, meshx, meshxd
     +                     , meshy, meshyd, np, params)
      IMPLICIT NONE
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C    
      INTEGER nx, ny, na, nl, np
C    
      INTEGER n, i, j, k
      DOUBLE PRECISION, DIMENSION(1, na) :: alpha
      DOUBLE PRECISION alphad(1, na)
      DOUBLE PRECISION, DIMENSION(1, np) :: params
      DOUBLE PRECISION, DIMENSION(0-nl:nx+nl, 0-nl:ny+nl) :: meshx, 
     +                                                       meshy
      DOUBLE PRECISION meshxd(0-nl:nx+nl, 0-nl:ny+nl), meshyd(0-nl:nx+nl
     +                 , 0-nl:ny+nl)
C
      DOUBLE PRECISION, DIMENSION(0:na+1) :: xc, yc, a, c, l, z
      DOUBLE PRECISION ycd(0:na+1), ad(0:na+1), cd(0:na+1), zd(0:na+1)
      DOUBLE PRECISION, DIMENSION(0:na) :: h, mu, b, d
      DOUBLE PRECISION bd(0:na), dd(0:na)
      DOUBLE PRECISION, DIMENSION(na) :: be
      DOUBLE PRECISION bed(na)
      DOUBLE PRECISION, DIMENSION(nx+1) :: xt, yt, phi, phi_ig, ps, xi, 
     +                                     y0
      DOUBLE PRECISION xtd(nx+1), ytd(nx+1), phid(nx+1), phi_igd(nx+1), 
     +                 xid(nx+1)
C
      DOUBLE PRECISION lx, ly, s_pos, s_hgt, s_wdt
      INTRINSIC DBLE
      DOUBLE PRECISION pwy1
      DOUBLE PRECISION pwr1
      INTEGER ii1
      INTEGER ii2
C
C
C
C
C
C
C     define numbers
C-----------------------------------------------------------------------
C
C     the design variables are the spline control points for the
C     y-coordinate of the mesh. they are initialised in the shape of a
C     squared cosine wave with a height of 1.0
C
C       *                                                               *
C   fixed       *                                               *    fixed
C          1 of na                                           na of na
C
C                       *                               *
C                  2 of na                             . . .
C
C                              *                *
C                       3 of na        *
C                                   . . .
C
C     the start and end points should NOT be provided, they are
C     accounted for by the meshing subroutine
C
C
      n = na + 1
C      nx = nx + 1
      lx = 1.0d0
      ly = params(1, 12)
      s_pos = params(1, 9)
      s_hgt = params(1, 10)
      s_wdt = params(1, 11)
C      j = 0.0d0
C
C
C     initialise control points:
C
      xc(0) = 0.0d0
      xc(n) = 1.0d0
      yc(0) = 1.0d0
      yc(n) = 1.0d0
      DO ii1=0,na+1
        ycd(ii1) = 0.D0
      ENDDO
C
      DO i=1,na
        xc(i) = DBLE(i)/(na+1.0d0)
        ycd(i) = alphad(1, i)
        yc(i) = alpha(1, i)
      ENDDO
      DO ii1=0,na+1
        ad(ii1) = 0.D0
      ENDDO
C
C
C
C
C
C
C
C     create spline polynomial
C-----------------------------------------------------------------------
C
C     first arrays
C
      DO i=0,n
        ad(i) = ycd(i)
        a(i) = yc(i)
      ENDDO
C
      DO i=0,n-1
        h(i) = xc(i+1) - xc(i)
      ENDDO
      DO ii1=1,na
        bed(ii1) = 0.D0
      ENDDO
C
      DO i=1,n-1
        bed(i) = 3*(ad(i+1)-ad(i))/h(i) - 3*(ad(i)-ad(i-1))/h(i-1)
        be(i) = 3*(a(i+1)-a(i))/h(i) - 3*(a(i)-a(i-1))/h(i-1)
      ENDDO
C
C
C
C     next stage of arrays
C
      l(0) = 1.0d0
      mu(0) = 0.0d0
      z(0) = 0.0d0
      DO ii1=0,na+1
        zd(ii1) = 0.D0
      ENDDO
C
      DO i=1,n-1
        l(i) = 2*(xc(i+1)-xc(i-1)) - h(i-1)*mu(i-1)
        mu(i) = h(i)/l(i)
        zd(i) = (bed(i)-h(i-1)*zd(i-1))/l(i)
        z(i) = (be(i)-h(i-1)*z(i-1))/l(i)
      ENDDO
C
      l(n) = 1.0d0
      zd(n) = 0.D0
      z(n) = 0.0d0
C
C
C     final arrays
C
      c(n) = 0.0d0
      DO ii1=0,na
        dd(ii1) = 0.D0
      ENDDO
      DO ii1=0,na
        bd(ii1) = 0.D0
      ENDDO
      DO ii1=0,na+1
        cd(ii1) = 0.D0
      ENDDO
C
      DO i=1,n
        j = n - i
        cd(j) = zd(j) - mu(j)*cd(j+1)
        c(j) = z(j) - mu(j)*c(j+1)
        bd(j) = (ad(j+1)-ad(j))/h(j) - h(j)*(cd(j+1)+2.0d0*cd(j))/3.0d0
        b(j) = (a(j+1)-a(j))/h(j) - h(j)*(c(j+1)+2.0d0*c(j))/3.0d0
        dd(j) = (cd(j+1)-cd(j))/(3.0d0*h(j))
        d(j) = (c(j+1)-c(j))/(3.0d0*h(j))
      ENDDO
      DO ii1=1,nx+1
        ytd(ii1) = 0.D0
      ENDDO
C
C
C
C
C
C
C     form the actual spline using polynomial coefficients
      DO i=1,nx+1
C
C
C     the actual points that form the spline
        xt(i) = DBLE(i-1)*lx/nx
C
C
C     determine what j value to use; check through control points
        DO k=0,n
          IF (xc(k) .GT. xt(i)) THEN
            GOTO 100
          ELSE
            j = 0
          END IF
        ENDDO
        GOTO 33
 100    j = k - 1
C
C     last value of yt seems buggy, add conditional statement
 33     IF (nx + 1 .EQ. i) j = na
C
C
C
C     do the actual spline formula
        ytd(i) = ad(j) + (xt(i)-xc(j))**1.0d0*bd(j) + (xt(i)-xc(j))**
     +    2.0d0*cd(j) + (xt(i)-xc(j))**3.0d0*dd(j)
        yt(i) = a(j) + b(j)*(xt(i)-xc(j))**1.0d0 + c(j)*(xt(i)-xc(j))**
     +    2.0d0 + d(j)*(xt(i)-xc(j))**3.0d0
      ENDDO
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C     adaptive meshing IF PARAMS SAYS SO
C-----------------------------------------------------------------------
      IF (1 .EQ. 1) THEN
C
C     create potential function and integrate it
C
        phi_ig(1) = 0.0d0
        DO ii1=1,nx+1
          phi_igd(ii1) = 0.D0
        ENDDO
        DO ii1=1,nx+1
          phid(ii1) = 0.D0
        ENDDO
C
        DO i=2,nx+1
          pwy1 = -(s_wdt*(i-s_pos*(nx+1))**2)
          pwr1 = 3**pwy1
          phid(i) = -(ytd(i)/yt(i)**2)
          phi(i) = 1.0d0/yt(i) + s_hgt*pwr1
          phi_igd(i) = phi_igd(i-1) + phid(i)
          phi_ig(i) = phi_ig(i-1) + phi(i)
        ENDDO
C
C
C     scale the potential function
C
        DO i=1,nx+1
          phi_igd(i) = ((phi_igd(i)-phi_igd(1))*(phi_ig(nx+1)-phi_ig(1))
     +      -(phi_ig(i)-phi_ig(1))*(phi_igd(nx+1)-phi_igd(1)))/(phi_ig(
     +      nx+1)-phi_ig(1))**2
          phi_ig(i) = (phi_ig(i)-phi_ig(1))/(phi_ig(nx+1)-phi_ig(1))
        ENDDO
        DO ii1=1,nx+1
          xid(ii1) = 0.D0
        ENDDO
C
C
C
C
C
C
C     seed the CDF and interpolate the values back to the x axis
C
        DO 44 i=1,nx+1
C
C     calculate seed points to use
          ps(i) = (DBLE(i)-1)/DBLE(nx)
          y0(i) = 0.0d0
C
C     compare psi_ig values to find points for linear interpolation
          DO k=1,nx+1
C
C     if a seed point is equal to an integrated point, avoid /0
            IF (phi_ig(k) .EQ. ps(i)) THEN
              GOTO 110
            ELSE IF (phi_ig(k) .GT. ps(i)) THEN
C
C     else perform linear interpolation
              GOTO 120
            END IF
          ENDDO
          GOTO 44
 110      xid(i) = 0.D0
          xi(i) = xt(k)
          GOTO 44
 120      xid(i) = (-((xt(k)-xt(k-1))*phi_igd(k-1)*(phi_ig(k)-phi_ig(k-1
     +      )))-(ps(i)-phi_ig(k-1))*(xt(k)-xt(k-1))*(phi_igd(k)-phi_igd(
     +      k-1)))/(phi_ig(k)-phi_ig(k-1))**2
          xi(i) = xt(k-1) + (ps(i)-phi_ig(k-1))*(xt(k)-xt(k-1))/(phi_ig(
     +      k)-phi_ig(k-1))
 44     CONTINUE
        DO ii1=1,nx+1
          xtd(ii1) = 0.D0
        ENDDO
C
C     exit checking loop
C
C     continue seed check loop
C
C
C
C
C
C
C     write to relevant vector for consistency
C
        DO i=1,nx
          xtd(i) = xid(i)
          xt(i) = xi(i)
        ENDDO
C
C
C
C
C
C
C     have to now re-fit y according to the spline
        DO i=1,nx+1
C
C     determine what j value to use; check through control points
          DO k=0,n
            IF (xc(k) .GT. xt(i)) THEN
              GOTO 130
            ELSE
              j = 0
            END IF
          ENDDO
          GOTO 55
 130      j = k - 1
C
C     sort out end of yt array
 55       IF (i .EQ. nx + 1) j = na
C
C
C
C
C     do the actual spline formula
          ytd(i) = ad(j) + bd(j)*(xt(i)-xc(j))**1.0d0 + b(j)*xtd(i) + cd
     +      (j)*(xt(i)-xc(j))**2.0d0 + c(j)*2.0d0*(xt(i)-xc(j))*xtd(i) +
     +      dd(j)*(xt(i)-xc(j))**3.0d0 + d(j)*3.0d0*(xt(i)-xc(j))**2.0D0
     +      *xtd(i)
          yt(i) = a(j) + b(j)*(xt(i)-xc(j))**1.0d0 + c(j)*(xt(i)-xc(j))
     +      **2.0d0 + d(j)*(xt(i)-xc(j))**3.0d0
        ENDDO
        DO ii1=0-nl,nl+ny
          DO ii2=0-nl,nl+nx
            meshxd(ii2, ii1) = 0.D0
          ENDDO
        ENDDO
      ELSE
        DO ii1=0-nl,nl+ny
          DO ii2=0-nl,nl+nx
            meshxd(ii2, ii1) = 0.D0
          ENDDO
        ENDDO
        DO ii1=1,nx+1
          xtd(ii1) = 0.D0
        ENDDO
      END IF
C
C
C
C
C
C
C
C
C
C
C     end of the adaptive meshing section ---------
C
C
C
C
C
C
C
C
C
C
C
C
C
C     create mesh_ using linear spacing; scale to account for halo cells
C-----------------------------------------------------------------------
C
C
C
C     meshX: body x cells
C
      DO i=0,nx
        DO j=0-nl,ny+nl
          meshxd(i, j) = xtd(i+1)
          meshx(i, j) = xt(i+1)
        ENDDO
      ENDDO
C
C
C     halo x cells
C
      DO i=1,nl
        DO j=0-nl,ny+nl
          meshxd(0-i, j) = 0.D0
          meshx(0-i, j) = -(DBLE(i)*lx/(nx+1))
        ENDDO
      ENDDO
C
      DO i=1,nl
        DO j=0-nl,ny+nl
          meshxd(nx+i, j) = 0.D0
          meshx(nx+i, j) = lx + DBLE(i)*lx/(nx+1)
        ENDDO
      ENDDO
C
C
C
C
C
C     meshY:
C
      DO i=0-nl,nx+nl
        DO j=0-nl,ny+nl
          meshy(i, j) = ly*(j*1.0d0/DBLE(ny)-0.5d0)
        ENDDO
      ENDDO
      DO ii1=0-nl,nl+ny
        DO ii2=0-nl,nl+nx
          meshyd(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
C
      DO i=0,nx
        DO j=0-nl,ny+nl
          meshyd(i, j) = ly*(j*1.0d0/DBLE(ny)-0.5d0)*ytd(i+1)
          meshy(i, j) = yt(i+1)*ly*(j*1.0d0/DBLE(ny)-0.5d0)
        ENDDO
      ENDDO
      END

C  Differentiation of split_fwd in forward (tangent) mode:
C   variations   of useful results: u1 u2 u3 u5
C   with respect to varying inputs: flow
C**********************************************************************!
C                          Charlie Anderson                            !
C                  University of Bristol, March 2019                   !
C**********************************************************************!
C    
      SUBROUTINE SPLIT_FWD_D(nx, ny, nl, flow, flowd, u1, u1d, u2, u2d, 
     +                       u3, u3d, u5, u5d)
      IMPLICIT NONE
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
      INTEGER nx, ny, nl, nh, nb
      INTEGER i, j, r
      DOUBLE PRECISION, DIMENSION(1, 4*(nx+2*nl)*(ny+2*nl)), INTENT(IN) 
     +:: flow
      DOUBLE PRECISION, DIMENSION(1, 4*(nx+2*nl)*(ny+2*nl)), INTENT(IN) 
     +:: flowd
      DOUBLE PRECISION, DIMENSION(1-nl:nx+nl, 1-nl:ny+nl) :: u1, u2, u3
     +                                                       , u5
      DOUBLE PRECISION u1d(1-nl:nx+nl, 1-nl:ny+nl), u2d(1-nl:nx+nl, 1-nl
     +                 :ny+nl), u3d(1-nl:nx+nl, 1-nl:ny+nl), u5d(1-nl:nx
     +                 +nl, 1-nl:ny+nl)
      INTEGER ii2
      INTEGER ii1
C
C
C                                               1  2  3  4  5
C       1 2 3 4 5 6 7 ... 13 14 15     ==>      6  7  8  9  10
C                                               11 12 13 14 15
C
C
C
C
      nh = 2*nl*(nx+ny)
      nb = nx*ny
      DO ii1=1-nl,nl+ny
        DO ii2=1-nl,nl+nx
          u1d(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
C
C
C
C
C
C
C
C
C
C
C
C     assign first flow variable (wall_bottom, wall_top, inflow, outflow)
C
      DO j=1,nl
        DO i=1,nx
          r = 0
          u1d(i, 1-j) = flowd(1, r+(j-1)*nx+i)
          u1(i, 1-j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,nx
          r = nl*nx
          u1d(i, ny+j) = flowd(1, r+(j-1)*nx+i)
          u1(i, ny+j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 2*nl*nx
          u1d(1-j, i) = flowd(1, r+(j-1)*ny+i)
          u1(1-j, i) = flow(1, r+(j-1)*ny+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 2*nl*nx + nl*ny
          u1d(nx+j, i) = flowd(1, r+(j-1)*ny+i)
          u1(nx+j, i) = flow(1, r+(j-1)*ny+i)
        ENDDO
      ENDDO
      DO ii1=1-nl,nl+ny
        DO ii2=1-nl,nl+nx
          u2d(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
C
C
C
C
C     assign second flow variable (wall_bottom, wall_top, inflow, outflow)
C
      DO j=1,nl
        DO i=1,nx
          r = 1*nh + 0
          u2d(i, 1-j) = flowd(1, r+(j-1)*nx+i)
          u2(i, 1-j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,nx
          r = 1*nh + nl*nx
          u2d(i, ny+j) = flowd(1, r+(j-1)*nx+i)
          u2(i, ny+j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 1*nh + 2*nl*nx
          u2d(1-j, i) = flowd(1, r+(j-1)*ny+i)
          u2(1-j, i) = flow(1, r+(j-1)*ny+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 1*nh + 2*nl*nx + nl*ny
          u2d(nx+j, i) = flowd(1, r+(j-1)*ny+i)
          u2(nx+j, i) = flow(1, r+(j-1)*ny+i)
        ENDDO
      ENDDO
      DO ii1=1-nl,nl+ny
        DO ii2=1-nl,nl+nx
          u3d(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
C
C
C
C
C     assign third flow variable (wall_bottom, wall_top, inflow, outflow)
C
      DO j=1,nl
        DO i=1,nx
          r = 2*nh + 0
          u3d(i, 1-j) = flowd(1, r+(j-1)*nx+i)
          u3(i, 1-j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,nx
          r = 2*nh + nl*nx
          u3d(i, ny+j) = flowd(1, r+(j-1)*nx+i)
          u3(i, ny+j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 2*nh + 2*nl*nx
          u3d(1-j, i) = flowd(1, r+(j-1)*ny+i)
          u3(1-j, i) = flow(1, r+(j-1)*ny+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 2*nh + 2*nl*nx + nl*ny
          u3d(nx+j, i) = flowd(1, r+(j-1)*ny+i)
          u3(nx+j, i) = flow(1, r+(j-1)*ny+i)
        ENDDO
      ENDDO
      DO ii1=1-nl,nl+ny
        DO ii2=1-nl,nl+nx
          u5d(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
C
C
C
C     assign fifth flow variable (wall_bottom, wall_top, inflow, outflow)
C
      DO j=1,nl
        DO i=1,nx
          r = 3*nh + 0
          u5d(i, 1-j) = flowd(1, r+(j-1)*nx+i)
          u5(i, 1-j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,nx
          r = 3*nh + nl*nx
          u5d(i, ny+j) = flowd(1, r+(j-1)*nx+i)
          u5(i, ny+j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 3*nh + 2*nl*nx
          u5d(1-j, i) = flowd(1, r+(j-1)*ny+i)
          u5(1-j, i) = flow(1, r+(j-1)*ny+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 3*nh + 2*nl*nx + nl*ny
          u5d(nx+j, i) = flowd(1, r+(j-1)*ny+i)
          u5(nx+j, i) = flow(1, r+(j-1)*ny+i)
        ENDDO
      ENDDO
C
C
C
C
C     assign body cells
C
      DO j=1,ny
        DO i=1,nx
          r = 4*nh + 0*nb
          u1d(i, j) = flowd(1, r+(j-1)*nx+i)
          u1(i, j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,ny
        DO i=1,nx
          r = 4*nh + 1*nb
          u2d(i, j) = flowd(1, r+(j-1)*nx+i)
          u2(i, j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,ny
        DO i=1,nx
          r = 4*nh + 2*nb
          u3d(i, j) = flowd(1, r+(j-1)*nx+i)
          u3(i, j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,ny
        DO i=1,nx
          r = 4*nh + 3*nb
          u5d(i, j) = flowd(1, r+(j-1)*nx+i)
          u5(i, j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
      END

C  Differentiation of boundaries in forward (tangent) mode:
C   variations   of useful results: u1 u2 u3 u5
C   with respect to varying inputs: meshx meshy u1 u2 u3 u5
C**********************************************************************!
C                          Charlie Anderson                            !
C                  University of Bristol, March 2019                   !
C**********************************************************************!
C    
      SUBROUTINE BOUNDARIES_D(nx, ny, nl, np, params, u1, u1d, u2, u2d, 
     +                        u3, u3d, u5, u5d, meshx, meshxd, meshy, 
     +                        meshyd)
      IMPLICIT NONE
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
      INTEGER nx, ny, nl, np
      INTEGER i, j
      DOUBLE PRECISION, DIMENSION(1-nl:nx+nl, 1-nl:ny+nl) :: u1, u2, u3
     +                                                       , u5
      DOUBLE PRECISION u1d(1-nl:nx+nl, 1-nl:ny+nl), u2d(1-nl:nx+nl, 1-nl
     +                 :ny+nl), u3d(1-nl:nx+nl, 1-nl:ny+nl), u5d(1-nl:nx
     +                 +nl, 1-nl:ny+nl)
      DOUBLE PRECISION, DIMENSION(0-nl:nx+nl, 0-nl:ny+nl) :: meshx, 
     +                                                       meshy
      DOUBLE PRECISION meshxd(0-nl:nx+nl, 0-nl:ny+nl), meshyd(0-nl:nx+nl
     +                 , 0-nl:ny+nl)
      DOUBLE PRECISION, DIMENSION(1, np) :: params
      DOUBLE PRECISION minf, prat, gam, ga1, pinf, rinf, pstag, rstag, 
     +                 pext, k, vw1, vw2
      DOUBLE PRECISION kd, vw1d, vw2d
      DOUBLE PRECISION, DIMENSION(ny) :: pbc, rbc, mp2, uint, pext2
      DOUBLE PRECISION pbcd(ny), rbcd(ny), mp2d(ny), uintd(ny)
      DOUBLE PRECISION pwx1
      DOUBLE PRECISION pwx1d
      DOUBLE PRECISION pwy1
      DOUBLE PRECISION pwr1
      DOUBLE PRECISION pwr1d
      INTEGER ii1
C
C
C
C
C
C
C
C     perform calculations
C-----------------------------------------------------------------------
C
C     take the flow parameters from the input file
C
      minf = params(1, 1)
      prat = params(1, 2)
      gam = params(1, 3)
      ga1 = gam - 1.0d0
C
C
C     calculate non-reflecting inflow and outflow conditions
C
      pinf = 1.0d0/gam
      rinf = 1.0d0
      pwx1 = 1.0d0 + 0.5d0*ga1*minf*minf
      pwy1 = gam/ga1
      pwr1 = pwx1**pwy1
      pstag = pinf*pwr1
      pwx1 = 1.0d0 + 0.5d0*ga1*minf*minf
      pwy1 = 1.0d0/ga1
      pwr1 = pwx1**pwy1
      rstag = rinf*pwr1
      DO ii1=1,ny
        pbcd(ii1) = 0.D0
      ENDDO
      DO ii1=1,ny
        mp2d(ii1) = 0.D0
      ENDDO
      DO ii1=1,ny
        uintd(ii1) = 0.D0
      ENDDO
      DO ii1=1,ny
        rbcd(ii1) = 0.D0
      ENDDO
C
      DO i=1,ny
        uintd(i) = (u2d(1, i)*u1(1, i)-u2(1, i)*u1d(1, i))/u1(1, i)**2
        uint(i) = u2(1, i)/u1(1, i)
        mp2d(i) = (2.0d0*uint(i)*uintd(i)*ga1*(1.0d0/ga1+0.5d0*minf**
     +    2.0d0-0.5d0*uint(i)**2.0d0)+uint(i)**2.0d0*ga1*0.5d0*2.0d0*
     +    uint(i)*uintd(i))/(ga1*(1.0d0/ga1+0.5d0*minf**2.0d0-0.5d0*uint
     +    (i)**2.0d0))**2
        mp2(i) = uint(i)**2.0d0/(ga1*(1.0d0/ga1+0.5d0*minf**2.0d0-0.5d0*
     +    uint(i)**2.0d0))
        pwx1d = 0.5d0*ga1*mp2d(i)
        pwx1 = 1.0d0 + 0.5d0*ga1*mp2(i)
        pwy1 = gam/ga1
        IF (pwx1 .GT. 0.0 .OR. (pwx1 .LT. 0.0 .AND. pwy1 .EQ. INT(pwy1))
     +  ) THEN
          pwr1d = pwy1*pwx1**(pwy1-1)*pwx1d
        ELSE IF (pwx1 .EQ. 0.0 .AND. pwy1 .EQ. 1.0) THEN
          pwr1d = pwx1d
        ELSE
          pwr1d = 0.0
        END IF
        pwr1 = pwx1**pwy1
        pbcd(i) = -(pstag*pwr1d/pwr1**2)
        pbc(i) = pstag/pwr1
        pwx1d = 0.5d0*ga1*mp2d(i)
        pwx1 = 1.0d0 + 0.5d0*ga1*mp2(i)
        pwy1 = 1.0d0/ga1
        IF (pwx1 .GT. 0.0 .OR. (pwx1 .LT. 0.0 .AND. pwy1 .EQ. INT(pwy1))
     +  ) THEN
          pwr1d = pwy1*pwx1**(pwy1-1)*pwx1d
        ELSE IF (pwx1 .EQ. 0.0 .AND. pwy1 .EQ. 1.0) THEN
          pwr1d = pwx1d
        ELSE
          pwr1d = 0.0
        END IF
        pwr1 = pwx1**pwy1
        rbcd(i) = -(rstag*pwr1d/pwr1**2)
        rbc(i) = rstag/pwr1
        pext2(i) = pbc(i)*prat
      ENDDO
C
      pext = pinf*prat
C
C
C
C
C
C     inflow conditions;
C-----------------------------------------------------------------------
C
      DO j=1,nl
        DO i=1,ny
          u1d(1-j, i) = rbcd(i)
          u1(1-j, i) = rbc(i)
          u2d(1-j, i) = rbcd(i)*uint(i) + rbc(i)*uintd(i)
          u2(1-j, i) = rbc(i)*uint(i)
          u3d(1-j, i) = 0.D0
          u3(1-j, i) = 0.0d0
C      u3(1-j,i) = u3(1,i)
          u5d(1-j, i) = pbcd(i)/ga1 + 0.5d0*(rbcd(i)*uint(i)**2.0d0+rbc(
     +      i)*2.0d0*uint(i)*uintd(i))
          u5(1-j, i) = pbc(i)/ga1 + 0.5d0*rbc(i)*uint(i)**2.0d0
        ENDDO
      ENDDO
C
C
C
C
C
C
C     outflow conditions; transient for all but u5
C-----------------------------------------------------------------------
C
      DO j=1,nl
        DO i=1,ny
          u1d(nx+j, i) = u1d(nx, i)
          u1(nx+j, i) = u1(nx, i)
          u2d(nx+j, i) = u2d(nx, i)
          u2(nx+j, i) = u2(nx, i)
          u3d(nx+j, i) = 0.D0
          u3(nx+j, i) = 0.0d0
C      u3(nx+j,i) = u3(nx,i)
          u5d(nx+j, i) = (0.5d0*2.0d0*u2(nx, i)*u2d(nx, i)*u1(nx, i)-
     +      0.5d0*u2(nx, i)**2.0d0*u1d(nx, i))/u1(nx, i)**2
          u5(nx+j, i) = pext/ga1 + 0.5d0*u2(nx, i)**2.0d0/u1(nx, i)
        ENDDO
      ENDDO
C
C
C
C
C
C
C
C     solid wall; use transient solutions
C-----------------------------------------------------------------------
C
      DO j=1,nl
        DO i=1,nx
C     bottom wall
          u1d(i, 1-j) = u1d(i, 1)
          u1(i, 1-j) = u1(i, 1)
          u5d(i, 1-j) = u5d(i, 1)
          u5(i, 1-j) = u5(i, 1)
C     top wall
          u1d(i, ny+j) = u1d(i, ny)
          u1(i, ny+j) = u1(i, ny)
          u5d(i, ny+j) = u5d(i, ny)
          u5(i, ny+j) = u5(i, ny)
        ENDDO
      ENDDO
C
C
C
C
C
C
C     solid wall; set normal velocity to zero
C-----------------------------------------------------------------------
C
C
      DO j=1,nl
        DO i=1,nx
C
C
C     bottom wall
C
          vw1d = meshxd(i, 0) - meshxd(i-1, 0)
          vw1 = meshx(i, 0) - meshx(i-1, 0)
          vw2d = meshyd(i, 0) - meshyd(i-1, 0)
          vw2 = meshy(i, 0) - meshy(i-1, 0)
          kd = (2.0d0*(vw1d*u2(i, 1)+vw1*u2d(i, 1)+vw2d*u3(i, 1)+vw2*u3d
     +      (i, 1))*(vw1*vw1+vw2*vw2)-2.0d0*(vw1*u2(i, 1)+vw2*u3(i, 1))*
     +      (vw1d*vw1+vw1*vw1d+vw2d*vw2+vw2*vw2d))/(vw1*vw1+vw2*vw2)**2
          k = 2.0d0*(vw1*u2(i, 1)+vw2*u3(i, 1))/(vw1*vw1+vw2*vw2)
C
          u2d(i, 1-j) = kd*vw1 + k*vw1d - u2d(i, 1)
          u2(i, 1-j) = k*vw1 - u2(i, 1)
          u3d(i, 1-j) = kd*vw2 + k*vw2d - u3d(i, 1)
          u3(i, 1-j) = k*vw2 - u3(i, 1)
C
C
C
C     top wall
C
          vw1d = meshxd(i, ny) - meshxd(i-1, ny)
          vw1 = meshx(i, ny) - meshx(i-1, ny)
          vw2d = meshyd(i, ny) - meshyd(i-1, ny)
          vw2 = meshy(i, ny) - meshy(i-1, ny)
          kd = (2.0d0*(vw1d*u2(i, ny)+vw1*u2d(i, ny)+vw2d*u3(i, ny)+vw2*
     +      u3d(i, ny))*(vw1*vw1+vw2*vw2)-2.0d0*(vw1*u2(i, ny)+vw2*u3(i
     +      , ny))*(vw1d*vw1+vw1*vw1d+vw2d*vw2+vw2*vw2d))/(vw1*vw1+vw2*
     +      vw2)**2
          k = 2.0d0*(vw1*u2(i, ny)+vw2*u3(i, ny))/(vw1*vw1+vw2*vw2)
C
          u2d(i, ny+j) = kd*vw1 + k*vw1d - u2d(i, ny)
          u2(i, ny+j) = k*vw1 - u2(i, ny)
          u3d(i, ny+j) = kd*vw2 + k*vw2d - u3d(i, ny)
          u3(i, ny+j) = k*vw2 - u3(i, ny)
        ENDDO
      ENDDO
      END

C  Differentiation of fg_vector in forward (tangent) mode:
C   variations   of useful results: f g
C   with respect to varying inputs: f g u1 u2 u3 u5
C**********************************************************************!
C                          Charlie Anderson                            !
C                  University of Bristol, March 2019                   !
C**********************************************************************!
C    
      SUBROUTINE FG_VECTOR_D(f, fd, g, gd, u1, u1d, u2, u2d, u3, u3d, u5
     +                       , u5d)
      IMPLICIT NONE
C
C
C
      DOUBLE PRECISION u1, u2, u3, u5, p
      DOUBLE PRECISION u1d, u2d, u3d, u5d, pd
      DOUBLE PRECISION, DIMENSION(4) :: f, g
      DOUBLE PRECISION fd(4), gd(4)
C
C
      pd = 0.4d0*(u5d-(0.5d0*(u2d*u2+u2*u2d+u3d*u3+u3*u3d)*u1-0.5d0*(u2*
     +  u2+u3*u3)*u1d)/u1**2)
      p = 0.4d0*(u5-0.5d0*(u2*u2+u3*u3)/u1)
C
      fd(1) = u2d
      f(1) = u2
      fd(2) = ((u2d*u2+u2*u2d)*u1-u2**2*u1d)/u1**2 + pd
      f(2) = u2*u2/u1 + p
      fd(3) = ((u2d*u3+u2*u3d)*u1-u2*u3*u1d)/u1**2
      f(3) = u2*u3/u1
      fd(4) = ((u2d*(u5+p)+u2*(u5d+pd))*u1-u2*(u5+p)*u1d)/u1**2
      f(4) = u2*(u5+p)/u1
C
      gd(1) = u3d
      g(1) = u3
      gd(2) = ((u2d*u3+u2*u3d)*u1-u2*u3*u1d)/u1**2
      g(2) = u2*u3/u1
      gd(3) = ((u3d*u3+u3*u3d)*u1-u3**2*u1d)/u1**2 + pd
      g(3) = u3*u3/u1 + p
      gd(4) = ((u3d*(u5+p)+u3*(u5d+pd))*u1-u3*(u5+p)*u1d)/u1**2
      g(4) = u3*(u5+p)/u1
      END

C  Differentiation of jst_calcs in forward (tangent) mode:
C   variations   of useful results: da
C   with respect to varying inputs: u10 u11 u12 u3i area0 u50 area1
C                u51 u52 u20 u21 u22 u1i u30 u31 u32 u5i u2i da
C**********************************************************************!
C                          Charlie Anderson                            !
C                  University of Bristol, March 2019                   !
C**********************************************************************!
C    
      SUBROUTINE JST_CALCS_D(dt, np, params, da, dad, area1, area1d, 
     +                       area0, area0d, u12, u12d, u11, u11d, u10, 
     +                       u10d, u1i, u1id, u22, u22d, u21, u21d, u20
     +                       , u20d, u2i, u2id, u32, u32d, u31, u31d, 
     +                       u30, u30d, u3i, u3id, u52, u52d, u51, u51d
     +                       , u50, u50d, u5i, u5id)
      IMPLICIT NONE
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
      INTEGER np
      DOUBLE PRECISION, DIMENSION(1, np) :: params
      DOUBLE PRECISION, DIMENSION(4) :: da
      DOUBLE PRECISION dad(4)
      DOUBLE PRECISION u12, u11, u10, u1i, u22, u21, u20, u2i, u32, u31
     +                 , u30, u3i, u52, u51, u50, u5i, area1, area0, dt
     +                 , p2, p1, p0, pi, e2, e4, k2, k4, v1, v0, h
      DOUBLE PRECISION u12d, u11d, u10d, u1id, u22d, u21d, u20d, u2id, 
     +                 u32d, u31d, u30d, u3id, u52d, u51d, u50d, u5id, 
     +                 area1d, area0d, p2d, p1d, p0d, pid, e2d, e4d, v1d
     +                 , v0d, hd
      INTRINSIC DABS
      INTRINSIC DMAX1
      DOUBLE PRECISION dabs0
      DOUBLE PRECISION dabs0d
      DOUBLE PRECISION dabs1
      DOUBLE PRECISION dabs1d
      DOUBLE PRECISION dmax10
      DOUBLE PRECISION dmax10d
      DOUBLE PRECISION dabs2
      DOUBLE PRECISION dabs2d
      DOUBLE PRECISION dabs3
      DOUBLE PRECISION dabs3d
      DOUBLE PRECISION dabs4
      DOUBLE PRECISION dabs4d
      DOUBLE PRECISION dabs5
      DOUBLE PRECISION dabs5d
      DOUBLE PRECISION dabs6
      DOUBLE PRECISION dabs6d
      DOUBLE PRECISION dabs7
      DOUBLE PRECISION dabs7d
C
C
C
C
C
C     define constants and pressure sensors
C
      k2 = params(1, 6)
      k4 = params(1, 7)
C
      p2d = 0.4d0*(u52d-(0.5d0*(2.0d0*u22*u22d+2.0d0*u32*u32d)*u12-0.5d0
     +  *(u22**2.0d0+u32**2.0d0)*u12d)/u12**2)
      p2 = 0.4d0*(u52-0.5d0*(u22**2.0d0+u32**2.0d0)/u12)
      p1d = 0.4d0*(u51d-(0.5d0*(2.0d0*u21*u21d+2.0d0*u31*u31d)*u11-0.5d0
     +  *(u21**2.0d0+u31**2.0d0)*u11d)/u11**2)
      p1 = 0.4d0*(u51-0.5d0*(u21**2.0d0+u31**2.0d0)/u11)
      p0d = 0.4d0*(u50d-(0.5d0*(2.0d0*u20*u20d+2.0d0*u30*u30d)*u10-0.5d0
     +  *(u20**2.0d0+u30**2.0d0)*u10d)/u10**2)
      p0 = 0.4d0*(u50-0.5d0*(u20**2.0d0+u30**2.0d0)/u10)
      pid = 0.4d0*(u5id-(0.5d0*(2.0d0*u2i*u2id+2.0d0*u3i*u3id)*u1i-0.5d0
     +  *(u2i**2.0d0+u3i**2.0d0)*u1id)/u1i**2)
      pi = 0.4d0*(u5i-0.5d0*(u2i**2.0d0+u3i**2.0d0)/u1i)
      IF (p2 - 2.0d0*p1 + p0 .GE. 0.) THEN
        dabs0d = p2d - 2.0d0*p1d + p0d
        dabs0 = p2 - 2.0d0*p1 + p0
      ELSE
        dabs0d = -(p2d-2.0d0*p1d+p0d)
        dabs0 = -(p2-2.0d0*p1+p0)
      END IF
      IF (p2 .GE. 0.) THEN
        dabs2d = p2d
        dabs2 = p2
      ELSE
        dabs2d = -p2d
        dabs2 = -p2
      END IF
      IF (p1 .GE. 0.) THEN
        dabs4d = p1d
        dabs4 = p1
      ELSE
        dabs4d = -p1d
        dabs4 = -p1
      END IF
      IF (p0 .GE. 0.) THEN
        dabs6d = p0d
        dabs6 = p0
      ELSE
        dabs6d = -p0d
        dabs6 = -p0
      END IF
C
      v1d = (dabs0d*(dabs2+2.0d0*dabs4+dabs6)-dabs0*(dabs2d+2.0d0*dabs4d
     +  +dabs6d))/(dabs2+2.0d0*dabs4+dabs6)**2
      v1 = dabs0/(dabs2+2.0d0*dabs4+dabs6)
      IF (p1 - 2.0d0*p0 + pi .GE. 0.) THEN
        dabs1d = p1d - 2.0d0*p0d + pid
        dabs1 = p1 - 2.0d0*p0 + pi
      ELSE
        dabs1d = -(p1d-2.0d0*p0d+pid)
        dabs1 = -(p1-2.0d0*p0+pi)
      END IF
      IF (p1 .GE. 0.) THEN
        dabs3d = p1d
        dabs3 = p1
      ELSE
        dabs3d = -p1d
        dabs3 = -p1
      END IF
      IF (p0 .GE. 0.) THEN
        dabs5d = p0d
        dabs5 = p0
      ELSE
        dabs5d = -p0d
        dabs5 = -p0
      END IF
      IF (pi .GE. 0.) THEN
        dabs7d = pid
        dabs7 = pi
      ELSE
        dabs7d = -pid
        dabs7 = -pi
      END IF
      v0d = (dabs1d*(dabs3+2.0d0*dabs5+dabs7)-dabs1*(dabs3d+2.0d0*dabs5d
     +  +dabs7d))/(dabs3+2.0d0*dabs5+dabs7)**2
      v0 = dabs1/(dabs3+2.0d0*dabs5+dabs7)
      IF (v1 .LT. v0) THEN
        dmax10d = v0d
        dmax10 = v0
      ELSE
        dmax10d = v1d
        dmax10 = v1
      END IF
C
      e2d = k2*dmax10d
      e2 = k2*dmax10
      IF (0.0d0 .LT. k4 - e2) THEN
        e4d = -e2d
        e4 = k4 - e2
      ELSE
        e4 = 0.0d0
        e4d = 0.D0
      END IF
C
      hd = 0.5d0*(area1d+area0d)
      h = 0.5d0*(area1+area0)
C
C
C
C
C
C     now calculate the actual dissipation terms
C
      dad(1) = hd*(e2*(u11-u10)-e4*(u12-3.0d0*u11+3.0d0*u10-u1i))/dt + h
     +  *(e2d*(u11-u10)+e2*(u11d-u10d)-e4d*(u12-3.0d0*u11+3.0d0*u10-u1i)
     +  -e4*(u12d-3.0d0*u11d+3.0d0*u10d-u1id))/dt
      da(1) = h/dt*(e2*(u11-u10)-e4*(u12-3.0d0*u11+3.0d0*u10-u1i))
      dad(2) = hd*(e2*(u21-u20)-e4*(u22-3.0d0*u21+3.0d0*u20-u2i))/dt + h
     +  *(e2d*(u21-u20)+e2*(u21d-u20d)-e4d*(u22-3.0d0*u21+3.0d0*u20-u2i)
     +  -e4*(u22d-3.0d0*u21d+3.0d0*u20d-u2id))/dt
      da(2) = h/dt*(e2*(u21-u20)-e4*(u22-3.0d0*u21+3.0d0*u20-u2i))
      dad(3) = hd*(e2*(u31-u30)-e4*(u32-3.0d0*u31+3.0d0*u30-u3i))/dt + h
     +  *(e2d*(u31-u30)+e2*(u31d-u30d)-e4d*(u32-3.0d0*u31+3.0d0*u30-u3i)
     +  -e4*(u32d-3.0d0*u31d+3.0d0*u30d-u3id))/dt
      da(3) = h/dt*(e2*(u31-u30)-e4*(u32-3.0d0*u31+3.0d0*u30-u3i))
      dad(4) = hd*(e2*(u51-u50)-e4*(u52-3.0d0*u51+3.0d0*u50-u5i))/dt + h
     +  *(e2d*(u51-u50)+e2*(u51d-u50d)-e4d*(u52-3.0d0*u51+3.0d0*u50-u5i)
     +  -e4*(u52d-3.0d0*u51d+3.0d0*u50d-u5id))/dt
      da(4) = h/dt*(e2*(u51-u50)-e4*(u52-3.0d0*u51+3.0d0*u50-u5i))
      END

C  Differentiation of split_rev in forward (tangent) mode:
C   variations   of useful results: flow
C   with respect to varying inputs: flow u1 u2 u3 u5
C**********************************************************************!
C                          Charlie Anderson                            !
C                  University of Bristol, March 2019                   !
C**********************************************************************!
C    
      SUBROUTINE SPLIT_REV_D(nx, ny, nl, flow, flowd, u1, u1d, u2, u2d, 
     +                       u3, u3d, u5, u5d)
      IMPLICIT NONE
C
C
C
C
C
C
C
C
C
C
      INTEGER nx, ny, nl, nh, nb
      INTEGER i, j, r
      DOUBLE PRECISION, DIMENSION(1, 4*(nx+2*nl)*(ny+2*nl)) :: flow
      DOUBLE PRECISION flowd(1, 4*(nx+2*nl)*(ny+2*nl))
      DOUBLE PRECISION, DIMENSION(1-nl:nx+nl, 1-nl:ny+nl), INTENT(IN) ::
     +u1, u2, u3, u5
      DOUBLE PRECISION, DIMENSION(1-nl:nx+nl, 1-nl:ny+nl), INTENT(IN) ::
     +u1d, u2d, u3d, u5d
C
C
C
C         1  2  3  4  5
C         6  7  8  9  10        ==>       1 2 3 4 5 6 7 ... 13 14 15    
C         11 12 13 14 15
C
C
      nh = 2*nl*(nx+ny)
      nb = nx*ny
C
C
C
C
C
C
C
C
C
C
C
C     assign first flow variable (wall_bottom, wall_top, inflow, outflow)
C
      DO j=1,nl
        DO i=1,nx
          r = 0
          flowd(1, r+(j-1)*nx+i) = u1d(i, 1-j)
          flow(1, r+(j-1)*nx+i) = u1(i, 1-j)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,nx
          r = nl*nx
          flowd(1, r+(j-1)*nx+i) = u1d(i, ny+j)
          flow(1, r+(j-1)*nx+i) = u1(i, ny+j)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 2*nl*nx
          flowd(1, r+(j-1)*ny+i) = u1d(1-j, i)
          flow(1, r+(j-1)*ny+i) = u1(1-j, i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 2*nl*nx + nl*ny
          flowd(1, r+(j-1)*ny+i) = u1d(nx+j, i)
          flow(1, r+(j-1)*ny+i) = u1(nx+j, i)
        ENDDO
      ENDDO
C
C
C
C
C     assign second flow variable (wall_bottom, wall_top, inflow, outflow)
C
      DO j=1,nl
        DO i=1,nx
          r = 1*nh + 0
          flowd(1, r+(j-1)*nx+i) = u2d(i, 1-j)
          flow(1, r+(j-1)*nx+i) = u2(i, 1-j)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,nx
          r = 1*nh + nl*nx
          flowd(1, r+(j-1)*nx+i) = u2d(i, ny+j)
          flow(1, r+(j-1)*nx+i) = u2(i, ny+j)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 1*nh + 2*nl*nx
          flowd(1, r+(j-1)*ny+i) = u2d(1-j, i)
          flow(1, r+(j-1)*ny+i) = u2(1-j, i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 1*nh + 2*nl*nx + nl*ny
          flowd(1, r+(j-1)*ny+i) = u2d(nx+j, i)
          flow(1, r+(j-1)*ny+i) = u2(nx+j, i)
        ENDDO
      ENDDO
C
C
C
C
C     assign third flow variable (wall_bottom, wall_top, inflow, outflow)
C
      DO j=1,nl
        DO i=1,nx
          r = 2*nh + 0
          flowd(1, r+(j-1)*nx+i) = u3d(i, 1-j)
          flow(1, r+(j-1)*nx+i) = u3(i, 1-j)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,nx
          r = 2*nh + nl*nx
          flowd(1, r+(j-1)*nx+i) = u3d(i, ny+j)
          flow(1, r+(j-1)*nx+i) = u3(i, ny+j)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 2*nh + 2*nl*nx
          flowd(1, r+(j-1)*ny+i) = u3d(1-j, i)
          flow(1, r+(j-1)*ny+i) = u3(1-j, i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 2*nh + 2*nl*nx + nl*ny
          flowd(1, r+(j-1)*ny+i) = u3d(nx+j, i)
          flow(1, r+(j-1)*ny+i) = u3(nx+j, i)
        ENDDO
      ENDDO
C
C
C
C     assign fifth flow variable (wall_bottom, wall_top, inflow, outflow)
C
      DO j=1,nl
        DO i=1,nx
          r = 3*nh + 0
          flowd(1, r+(j-1)*nx+i) = u5d(i, 1-j)
          flow(1, r+(j-1)*nx+i) = u5(i, 1-j)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,nx
          r = 3*nh + nl*nx
          flowd(1, r+(j-1)*nx+i) = u5d(i, ny+j)
          flow(1, r+(j-1)*nx+i) = u5(i, ny+j)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 3*nh + 2*nl*nx
          flowd(1, r+(j-1)*ny+i) = u5d(1-j, i)
          flow(1, r+(j-1)*ny+i) = u5(1-j, i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 3*nh + 2*nl*nx + nl*ny
          flowd(1, r+(j-1)*ny+i) = u5d(nx+j, i)
          flow(1, r+(j-1)*ny+i) = u5(nx+j, i)
        ENDDO
      ENDDO
C
C
C
C
C     assign body cells
C
      DO j=1,ny
        DO i=1,nx
          r = 4*nh + 0*nb
          flowd(1, r+(j-1)*nx+i) = u1d(i, j)
          flow(1, r+(j-1)*nx+i) = u1(i, j)
        ENDDO
      ENDDO
C
      DO j=1,ny
        DO i=1,nx
          r = 4*nh + 1*nb
          flowd(1, r+(j-1)*nx+i) = u2d(i, j)
          flow(1, r+(j-1)*nx+i) = u2(i, j)
        ENDDO
      ENDDO
C
      DO j=1,ny
        DO i=1,nx
          r = 4*nh + 2*nb
          flowd(1, r+(j-1)*nx+i) = u3d(i, j)
          flow(1, r+(j-1)*nx+i) = u3(i, j)
        ENDDO
      ENDDO
C
      DO j=1,ny
        DO i=1,nx
          r = 4*nh + 3*nb
          flowd(1, r+(j-1)*nx+i) = u5d(i, j)
          flow(1, r+(j-1)*nx+i) = u5(i, j)
        ENDDO
      ENDDO
      END

