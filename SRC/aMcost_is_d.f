C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.14 (r7260) - 18 Jan 2019 10:11
C
C  Differentiation of cost_is in forward (tangent) mode:
C   variations   of useful results: jcost
C   with respect to varying inputs: alpha flow
C   RW status of diff variables: alpha:in flow:in jcost:out
C**********************************************************************!
C                          Charlie Anderson                            !
C                  University of Bristol, March 2019                   !
C**********************************************************************!
C    
      SUBROUTINE COST_IS_D(nx, ny, nl, na, np, params, flow, flowd, 
     +                     alpha, alphad, jcost, jcostd)
      IMPLICIT NONE
C      
C
C
C
C
C
C
C
C
C
C
      INTEGER nx, ny, nl, na, np
      INTEGER i
C
      DOUBLE PRECISION ds, jcost
      DOUBLE PRECISION dsd, jcostd
C
      DOUBLE PRECISION, DIMENSION(1, na) :: alpha
      DOUBLE PRECISION alphad(1, na)
      DOUBLE PRECISION, DIMENSION(1, np) :: params
      DOUBLE PRECISION, DIMENSION(1, 4*(nx+2*nl)*(ny+2*nl)) :: flow
      DOUBLE PRECISION flowd(1, 4*(nx+2*nl)*(ny+2*nl))
      DOUBLE PRECISION, DIMENSION(0-nl:nx+nl, 0-nl:ny+nl) :: meshx, 
     +                                                       meshy
      DOUBLE PRECISION meshxd(0-nl:nx+nl, 0-nl:ny+nl), meshyd(0-nl:nx+nl
     +                 , 0-nl:ny+nl)
      DOUBLE PRECISION, DIMENSION(1-nl:nx+nl, 1-nl:ny+nl) :: u1, u2, u3
     +                                                       , u5, pres
      DOUBLE PRECISION u1d(1-nl:nx+nl, 1-nl:ny+nl), u2d(1-nl:nx+nl, 1-nl
     +                 :ny+nl), u3d(1-nl:nx+nl, 1-nl:ny+nl), u5d(1-nl:nx
     +                 +nl, 1-nl:ny+nl), presd(1-nl:nx+nl, 1-nl:ny+nl)
      INTRINSIC DSQRT
C
C
C
C
C
C
      CALL SPLIT_FWD2_D(nx, ny, nl, flow, flowd, u1, u1d, u2, u2d, u3, 
     +                  u3d, u5, u5d)
C
      CALL PRESSURE_D(nx, ny, nl, pres, presd, u1, u1d, u2, u2d, u3, u3d
     +                , u5, u5d)
C
      CALL MESHING2_D(nx, ny, na, nl, alpha, alphad, meshx, meshxd, 
     +                meshy, meshyd, np, params)
      jcostd = 0.D0
C
C
C     cost function - just integrate pressure along walls. assume line
C     of symmetry
C
      DO i=1,nx
C
        dsd = 2.0d0*(meshx(i, ny)+meshx(i-1, ny))*(meshxd(i, ny)+meshxd(
     +    i-1, ny)) + 2.0d0*(meshy(i, ny)+meshy(i-1, ny))*(meshyd(i, ny)
     +    +meshyd(i-1, ny))
        ds = (meshx(i, ny)+meshx(i-1, ny))**2.0d0 + (meshy(i, ny)+meshy(
     +    i-1, ny))**2.0d0
        IF (ds .EQ. 0.0) THEN
          dsd = 0.D0
        ELSE
          dsd = dsd/(2.D0*DSQRT(ds))
        END IF
        ds = DSQRT(ds)
C
        jcostd = jcostd + 2*(dsd*pres(i, ny)) + 2*(ds*presd(i, ny))
        jcost = jcost + 2*ds*pres(i, ny)
      ENDDO
      END

C  Differentiation of split_fwd2 in forward (tangent) mode:
C   variations   of useful results: u1 u2 u3 u5
C   with respect to varying inputs: flow
C**********************************************************************!
C                          Charlie Anderson                            !
C                  University of Bristol, March 2019                   !
C**********************************************************************!
C    
      SUBROUTINE SPLIT_FWD2_D(nx, ny, nl, flow, flowd, u1, u1d, u2, u2d
     +                        , u3, u3d, u5, u5d)
      IMPLICIT NONE
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
      INTEGER nx, ny, nl, nh, nb
      INTEGER i, j, r
      DOUBLE PRECISION, DIMENSION(1, 4*(nx+2*nl)*(ny+2*nl)), INTENT(IN) 
     +:: flow
      DOUBLE PRECISION, DIMENSION(1, 4*(nx+2*nl)*(ny+2*nl)), INTENT(IN) 
     +:: flowd
      DOUBLE PRECISION, DIMENSION(1-nl:nx+nl, 1-nl:ny+nl) :: u1, u2, u3
     +                                                       , u5
      DOUBLE PRECISION u1d(1-nl:nx+nl, 1-nl:ny+nl), u2d(1-nl:nx+nl, 1-nl
     +                 :ny+nl), u3d(1-nl:nx+nl, 1-nl:ny+nl), u5d(1-nl:nx
     +                 +nl, 1-nl:ny+nl)
      INTEGER ii2
      INTEGER ii1
C      double precision :: 
C
C
C                                               1  2  3  4  5
C       1 2 3 4 5 6 7 ... 13 14 15     ==>      6  7  8  9  10
C                                               11 12 13 14 15
C
C
C
C
      nh = 2*nl*(nx+ny)
      nb = nx*ny
      DO ii1=1-nl,nl+ny
        DO ii2=1-nl,nl+nx
          u1d(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
C
C
C
C
C
C
C
C
C
C
C     assign first flow variable (wall_bottom, wall_top, inflow, outflow)
C
      DO j=1,nl
        DO i=1,nx
          r = 0
          u1d(i, 1-j) = flowd(1, r+(j-1)*nx+i)
          u1(i, 1-j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,nx
          r = nl*nx
          u1d(i, ny+j) = flowd(1, r+(j-1)*nx+i)
          u1(i, ny+j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 2*nl*nx
          u1d(1-j, i) = flowd(1, r+(j-1)*ny+i)
          u1(1-j, i) = flow(1, r+(j-1)*ny+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 2*nl*nx + nl*ny
          u1d(nx+j, i) = flowd(1, r+(j-1)*ny+i)
          u1(nx+j, i) = flow(1, r+(j-1)*ny+i)
        ENDDO
      ENDDO
      DO ii1=1-nl,nl+ny
        DO ii2=1-nl,nl+nx
          u2d(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
C
C
C
C
C     assign second flow variable (wall_bottom, wall_top, inflow, outflow)
C
      DO j=1,nl
        DO i=1,nx
          r = 1*nh + 0
          u2d(i, 1-j) = flowd(1, r+(j-1)*nx+i)
          u2(i, 1-j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,nx
          r = 1*nh + nl*nx
          u2d(i, ny+j) = flowd(1, r+(j-1)*nx+i)
          u2(i, ny+j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 1*nh + 2*nl*nx
          u2d(1-j, i) = flowd(1, r+(j-1)*ny+i)
          u2(1-j, i) = flow(1, r+(j-1)*ny+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 1*nh + 2*nl*nx + nl*ny
          u2d(nx+j, i) = flowd(1, r+(j-1)*ny+i)
          u2(nx+j, i) = flow(1, r+(j-1)*ny+i)
        ENDDO
      ENDDO
      DO ii1=1-nl,nl+ny
        DO ii2=1-nl,nl+nx
          u3d(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
C
C
C
C
C     assign third flow variable (wall_bottom, wall_top, inflow, outflow)
C
      DO j=1,nl
        DO i=1,nx
          r = 2*nh + 0
          u3d(i, 1-j) = flowd(1, r+(j-1)*nx+i)
          u3(i, 1-j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,nx
          r = 2*nh + nl*nx
          u3d(i, ny+j) = flowd(1, r+(j-1)*nx+i)
          u3(i, ny+j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 2*nh + 2*nl*nx
          u3d(1-j, i) = flowd(1, r+(j-1)*ny+i)
          u3(1-j, i) = flow(1, r+(j-1)*ny+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 2*nh + 2*nl*nx + nl*ny
          u3d(nx+j, i) = flowd(1, r+(j-1)*ny+i)
          u3(nx+j, i) = flow(1, r+(j-1)*ny+i)
        ENDDO
      ENDDO
      DO ii1=1-nl,nl+ny
        DO ii2=1-nl,nl+nx
          u5d(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
C
C
C
C     assign fifth flow variable (wall_bottom, wall_top, inflow, outflow)
C
      DO j=1,nl
        DO i=1,nx
          r = 3*nh + 0
          u5d(i, 1-j) = flowd(1, r+(j-1)*nx+i)
          u5(i, 1-j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,nx
          r = 3*nh + nl*nx
          u5d(i, ny+j) = flowd(1, r+(j-1)*nx+i)
          u5(i, ny+j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 3*nh + 2*nl*nx
          u5d(1-j, i) = flowd(1, r+(j-1)*ny+i)
          u5(1-j, i) = flow(1, r+(j-1)*ny+i)
        ENDDO
      ENDDO
C
      DO j=1,nl
        DO i=1,ny
          r = 3*nh + 2*nl*nx + nl*ny
          u5d(nx+j, i) = flowd(1, r+(j-1)*ny+i)
          u5(nx+j, i) = flow(1, r+(j-1)*ny+i)
        ENDDO
      ENDDO
C
C
C
C
C     assign body cells
C
      DO j=1,ny
        DO i=1,nx
          r = 4*nh + 0*nb
          u1d(i, j) = flowd(1, r+(j-1)*nx+i)
          u1(i, j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,ny
        DO i=1,nx
          r = 4*nh + 1*nb
          u2d(i, j) = flowd(1, r+(j-1)*nx+i)
          u2(i, j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,ny
        DO i=1,nx
          r = 4*nh + 2*nb
          u3d(i, j) = flowd(1, r+(j-1)*nx+i)
          u3(i, j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
C
      DO j=1,ny
        DO i=1,nx
          r = 4*nh + 3*nb
          u5d(i, j) = flowd(1, r+(j-1)*nx+i)
          u5(i, j) = flow(1, r+(j-1)*nx+i)
        ENDDO
      ENDDO
      END

C  Differentiation of pressure in forward (tangent) mode:
C   variations   of useful results: pres
C   with respect to varying inputs: u1 u2 u3 u5
C**********************************************************************!
C                          Charlie Anderson                            !
C                  University of Bristol, March 2019                   !
C**********************************************************************!
C    
      SUBROUTINE PRESSURE_D(nx, ny, nl, pres, presd, u1, u1d, u2, u2d, 
     +                      u3, u3d, u5, u5d)
      IMPLICIT NONE
C
C
C
C
C
C
C
C
      INTEGER nx, ny, nl
      INTEGER i, j
      DOUBLE PRECISION, DIMENSION(1-nl:nx+nl, 1-nl:ny+nl) :: pres
      DOUBLE PRECISION presd(1-nl:nx+nl, 1-nl:ny+nl)
      DOUBLE PRECISION, DIMENSION(1-nl:nx+nl, 1-nl:ny+nl), INTENT(IN) ::
     +u1, u2, u3, u5
      DOUBLE PRECISION, DIMENSION(1-nl:nx+nl, 1-nl:ny+nl), INTENT(IN) ::
     +u1d, u2d, u3d, u5d
      DOUBLE PRECISION ga1
      INTEGER ii2
      INTEGER ii1
C
C
      ga1 = 0.4d0
      DO ii1=1-nl,nl+ny
        DO ii2=1-nl,nl+nx
          presd(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
C
C
C
      DO j=1-nl,ny+nl
        DO i=1-nl,nx+nl
C
          IF (u1(i, j) .NE. 0.0d0) THEN
            presd(i, j) = ga1*(u5d(i, j)-(0.5d0*(2.0d0*u2(i, j)*u2d(i, j
     +        )+2.0d0*u3(i, j)*u3d(i, j))*u1(i, j)-0.5d0*(u2(i, j)**
     +        2.0d0+u3(i, j)**2.0d0)*u1d(i, j))/u1(i, j)**2)
            pres(i, j) = ga1*(u5(i, j)-0.5d0*(u2(i, j)**2.0d0+u3(i, j)**
     +        2.0d0)/u1(i, j))
          END IF
        ENDDO
      ENDDO
      END

C  Differentiation of meshing2 in forward (tangent) mode:
C   variations   of useful results: meshx meshy
C   with respect to varying inputs: alpha
C**********************************************************************!
C                          Charlie Anderson                            !
C                  University of Bristol, March 2019                   !
C**********************************************************************!
C    
      SUBROUTINE MESHING2_D(nx, ny, na, nl, alpha, alphad, meshx, meshxd
     +                      , meshy, meshyd, np, params)
      IMPLICIT NONE
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C    
      INTEGER nx, ny, na, nl, np
C    
      INTEGER n, i, j, k
      DOUBLE PRECISION, DIMENSION(1, na) :: alpha
      DOUBLE PRECISION alphad(1, na)
      DOUBLE PRECISION, DIMENSION(1, np) :: params
      DOUBLE PRECISION, DIMENSION(0-nl:nx+nl, 0-nl:ny+nl) :: meshx, 
     +                                                       meshy
      DOUBLE PRECISION meshxd(0-nl:nx+nl, 0-nl:ny+nl), meshyd(0-nl:nx+nl
     +                 , 0-nl:ny+nl)
C
      DOUBLE PRECISION, DIMENSION(0:na+1) :: xc, yc, a, c, l, z
      DOUBLE PRECISION ycd(0:na+1), ad(0:na+1), cd(0:na+1), zd(0:na+1)
      DOUBLE PRECISION, DIMENSION(0:na) :: h, mu, b, d
      DOUBLE PRECISION bd(0:na), dd(0:na)
      DOUBLE PRECISION, DIMENSION(na) :: be
      DOUBLE PRECISION bed(na)
      DOUBLE PRECISION, DIMENSION(nx+1) :: xt, yt, phi, phi_ig, ps, xi, 
     +                                     y0
      DOUBLE PRECISION xtd(nx+1), ytd(nx+1), phid(nx+1), phi_igd(nx+1), 
     +                 xid(nx+1)
C
      DOUBLE PRECISION lx, ly, s_pos, s_hgt, s_wdt
      INTRINSIC DBLE
      DOUBLE PRECISION pwy1
      DOUBLE PRECISION pwr1
      INTEGER ii1
      INTEGER ii2
C
C
C
C
C
C
C     define numbers
C-----------------------------------------------------------------------
C
C     the design variables are the spline control points for the
C     y-coordinate of the mesh. they are initialised in the shape of a
C     squared cosine wave with a height of 1.0
C
C       *                                                               *
C   fixed       *                                               *    fixed
C          1 of na                                           na of na
C
C                       *                               *
C                  2 of na                             . . .
C
C                              *                *
C                       3 of na        *
C                                   . . .
C
C     the start and end points should NOT be provided, they are
C     accounted for by the meshing subroutine
C
C
      n = na + 1
C      nx = nx + 1
      lx = 1.0d0
      ly = params(1, 12)
      s_pos = params(1, 9)
      s_hgt = params(1, 10)
      s_wdt = params(1, 11)
C      j = 0.0d0
C
C
C     initialise control points:
C
      xc(0) = 0.0d0
      xc(n) = 1.0d0
      yc(0) = 1.0d0
      yc(n) = 1.0d0
      DO ii1=0,na+1
        ycd(ii1) = 0.D0
      ENDDO
C
      DO i=1,na
        xc(i) = DBLE(i)/(na+1.0d0)
        ycd(i) = alphad(1, i)
        yc(i) = alpha(1, i)
      ENDDO
      DO ii1=0,na+1
        ad(ii1) = 0.D0
      ENDDO
C
C
C
C
C
C
C
C     create spline polynomial
C-----------------------------------------------------------------------
C
C     first arrays
C
      DO i=0,n
        ad(i) = ycd(i)
        a(i) = yc(i)
      ENDDO
C
      DO i=0,n-1
        h(i) = xc(i+1) - xc(i)
      ENDDO
      DO ii1=1,na
        bed(ii1) = 0.D0
      ENDDO
C
      DO i=1,n-1
        bed(i) = 3*(ad(i+1)-ad(i))/h(i) - 3*(ad(i)-ad(i-1))/h(i-1)
        be(i) = 3*(a(i+1)-a(i))/h(i) - 3*(a(i)-a(i-1))/h(i-1)
      ENDDO
C
C
C
C     next stage of arrays
C
      l(0) = 1.0d0
      mu(0) = 0.0d0
      z(0) = 0.0d0
      DO ii1=0,na+1
        zd(ii1) = 0.D0
      ENDDO
C
      DO i=1,n-1
        l(i) = 2*(xc(i+1)-xc(i-1)) - h(i-1)*mu(i-1)
        mu(i) = h(i)/l(i)
        zd(i) = (bed(i)-h(i-1)*zd(i-1))/l(i)
        z(i) = (be(i)-h(i-1)*z(i-1))/l(i)
      ENDDO
C
      l(n) = 1.0d0
      zd(n) = 0.D0
      z(n) = 0.0d0
C
C
C     final arrays
C
      c(n) = 0.0d0
      DO ii1=0,na
        dd(ii1) = 0.D0
      ENDDO
      DO ii1=0,na
        bd(ii1) = 0.D0
      ENDDO
      DO ii1=0,na+1
        cd(ii1) = 0.D0
      ENDDO
C
      DO i=1,n
        j = n - i
        cd(j) = zd(j) - mu(j)*cd(j+1)
        c(j) = z(j) - mu(j)*c(j+1)
        bd(j) = (ad(j+1)-ad(j))/h(j) - h(j)*(cd(j+1)+2.0d0*cd(j))/3.0d0
        b(j) = (a(j+1)-a(j))/h(j) - h(j)*(c(j+1)+2.0d0*c(j))/3.0d0
        dd(j) = (cd(j+1)-cd(j))/(3.0d0*h(j))
        d(j) = (c(j+1)-c(j))/(3.0d0*h(j))
      ENDDO
      DO ii1=1,nx+1
        ytd(ii1) = 0.D0
      ENDDO
C
C
C
C
C
C     form the actual spline using polynomial coefficients
      DO i=1,nx+1
C
C
C     the actual points that form the spline
        xt(i) = DBLE(i-1)*lx/nx
C
C
C     determine what j value to use; check through control points
        DO k=0,n
          IF (xc(k) .GT. xt(i)) THEN
            GOTO 100
          ELSE
            j = 0
          END IF
        ENDDO
        GOTO 33
 100    j = k - 1
C
C     last value of yt seems buggy, add conditional statement
 33     IF (nx + 1 .EQ. i) j = na
C
C
C
C     do the actual spline formula
        ytd(i) = ad(j) + (xt(i)-xc(j))**1.0d0*bd(j) + (xt(i)-xc(j))**
     +    2.0d0*cd(j) + (xt(i)-xc(j))**3.0d0*dd(j)
        yt(i) = a(j) + b(j)*(xt(i)-xc(j))**1.0d0 + c(j)*(xt(i)-xc(j))**
     +    2.0d0 + d(j)*(xt(i)-xc(j))**3.0d0
      ENDDO
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C     adaptive meshing IF PARAMS SAYS SO
C-----------------------------------------------------------------------
      IF (1 .EQ. 1) THEN
C
C     create potential function and integrate it
C
        phi_ig(1) = 0.0d0
        DO ii1=1,nx+1
          phi_igd(ii1) = 0.D0
        ENDDO
        DO ii1=1,nx+1
          phid(ii1) = 0.D0
        ENDDO
C
        DO i=2,nx+1
          pwy1 = -(s_wdt*(i-s_pos*(nx+1))**2)
          pwr1 = 3**pwy1
          phid(i) = -(ytd(i)/yt(i)**2)
          phi(i) = 1.0d0/yt(i) + s_hgt*pwr1
          phi_igd(i) = phi_igd(i-1) + phid(i)
          phi_ig(i) = phi_ig(i-1) + phi(i)
        ENDDO
C
C
C     scale the potential function
C
        DO i=1,nx+1
          phi_igd(i) = ((phi_igd(i)-phi_igd(1))*(phi_ig(nx+1)-phi_ig(1))
     +      -(phi_ig(i)-phi_ig(1))*(phi_igd(nx+1)-phi_igd(1)))/(phi_ig(
     +      nx+1)-phi_ig(1))**2
          phi_ig(i) = (phi_ig(i)-phi_ig(1))/(phi_ig(nx+1)-phi_ig(1))
        ENDDO
        DO ii1=1,nx+1
          xid(ii1) = 0.D0
        ENDDO
C
C
C
C
C
C
C     seed the CDF and interpolate the values back to the x axis
C
        DO 44 i=1,nx+1
C
C     calculate seed points to use
          ps(i) = (DBLE(i)-1)/DBLE(nx)
          y0(i) = 0.0d0
C
C     compare psi_ig values to find points for linear interpolation
          DO k=1,nx+1
C
C     if a seed point is equal to an integrated point, avoid /0
            IF (phi_ig(k) .EQ. ps(i)) THEN
              GOTO 110
            ELSE IF (phi_ig(k) .GT. ps(i)) THEN
C
C     else perform linear interpolation
              GOTO 120
            END IF
          ENDDO
          GOTO 44
 110      xid(i) = 0.D0
          xi(i) = xt(k)
          GOTO 44
 120      xid(i) = (-((xt(k)-xt(k-1))*phi_igd(k-1)*(phi_ig(k)-phi_ig(k-1
     +      )))-(ps(i)-phi_ig(k-1))*(xt(k)-xt(k-1))*(phi_igd(k)-phi_igd(
     +      k-1)))/(phi_ig(k)-phi_ig(k-1))**2
          xi(i) = xt(k-1) + (ps(i)-phi_ig(k-1))*(xt(k)-xt(k-1))/(phi_ig(
     +      k)-phi_ig(k-1))
 44     CONTINUE
        DO ii1=1,nx+1
          xtd(ii1) = 0.D0
        ENDDO
C
C     exit checking loop
C
C     continue seed check loop
C
C
C
C
C
C
C     write to relevant vector for consistency
C
        DO i=1,nx
          xtd(i) = xid(i)
          xt(i) = xi(i)
        ENDDO
C
C
C
C
C
C
C     have to now re-fit y according to the spline
        DO i=1,nx+1
C
C     determine what j value to use; check through control points
          DO k=0,n
            IF (xc(k) .GT. xt(i)) THEN
              GOTO 130
            ELSE
              j = 0
            END IF
          ENDDO
          GOTO 55
 130      j = k - 1
C
C     sort out end of yt array
 55       IF (i .EQ. nx + 1) j = na
C
C
C
C
C     do the actual spline formula
          ytd(i) = ad(j) + bd(j)*(xt(i)-xc(j))**1.0d0 + b(j)*xtd(i) + cd
     +      (j)*(xt(i)-xc(j))**2.0d0 + c(j)*2.0d0*(xt(i)-xc(j))*xtd(i) +
     +      dd(j)*(xt(i)-xc(j))**3.0d0 + d(j)*3.0d0*(xt(i)-xc(j))**2.0D0
     +      *xtd(i)
          yt(i) = a(j) + b(j)*(xt(i)-xc(j))**1.0d0 + c(j)*(xt(i)-xc(j))
     +      **2.0d0 + d(j)*(xt(i)-xc(j))**3.0d0
        ENDDO
        DO ii1=0-nl,nl+ny
          DO ii2=0-nl,nl+nx
            meshxd(ii2, ii1) = 0.D0
          ENDDO
        ENDDO
      ELSE
        DO ii1=0-nl,nl+ny
          DO ii2=0-nl,nl+nx
            meshxd(ii2, ii1) = 0.D0
          ENDDO
        ENDDO
        DO ii1=1,nx+1
          xtd(ii1) = 0.D0
        ENDDO
      END IF
C
C
C
C
C
C
C
C
C
C
C     end of the adaptive meshing section ---------
C
C
C
C
C
C
C
C
C
C
C
C
C
C     create mesh_ using linear spacing; scale to account for halo cells
C-----------------------------------------------------------------------
C
C
C
C     meshX: body x cells
C
      DO i=0,nx
        DO j=0-nl,ny+nl
          meshxd(i, j) = xtd(i+1)
          meshx(i, j) = xt(i+1)
        ENDDO
      ENDDO
C
C
C     halo x cells
C
      DO i=1,nl
        DO j=0-nl,ny+nl
          meshxd(0-i, j) = 0.D0
          meshx(0-i, j) = -(DBLE(i)*lx/(nx+1))
        ENDDO
      ENDDO
C
      DO i=1,nl
        DO j=0-nl,ny+nl
          meshxd(nx+i, j) = 0.D0
          meshx(nx+i, j) = lx + DBLE(i)*lx/(nx+1)
        ENDDO
      ENDDO
C
C
C
C
C
C     meshY:
C
      DO i=0-nl,nx+nl
        DO j=0-nl,ny+nl
          meshy(i, j) = ly*(j*1.0d0/DBLE(ny)-0.5d0)
        ENDDO
      ENDDO
      DO ii1=0-nl,nl+ny
        DO ii2=0-nl,nl+nx
          meshyd(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
C
      DO i=0,nx
        DO j=0-nl,ny+nl
          meshyd(i, j) = ly*(j*1.0d0/DBLE(ny)-0.5d0)*ytd(i+1)
          meshy(i, j) = yt(i+1)*ly*(j*1.0d0/DBLE(ny)-0.5d0)
        ENDDO
      ENDDO
      END

